import { test, expect } from '@playwright/test';

test.describe('{{APP_NAME}} - Smoke Tests', () => {
  test.beforeEach(async ({ page }) => {
    // Set up any necessary test data or authentication
    // This is a basic smoke test to verify the application starts correctly
  });

  test('health endpoint returns healthy status', async ({ request }) => {
    const response = await request.get('/health');
    expect(response.status()).toBe(200);

    const health = await response.json();
    expect(health.status).toBe('healthy');
    expect(health.application).toBe('{{APP_NAME}}');
    expect(health.fhir).toBeDefined();
    expect(health.fhir.status).toBe('connected');
  });

  test('FHIR API endpoint is accessible', async ({ request }) => {
    const response = await request.get('/api/fhir');
    expect(response.status()).toBe(200);

    const fhirInfo = await response.json();
    expect(fhirInfo.message).toBe('FHIR API is running');
    expect(fhirInfo.version).toBeDefined();
  });

{{#EACH_RESOURCE}}
  test('{{RESOURCE_NAME}} endpoint returns valid FHIR Bundle', async ({ request }) => {
    const response = await request.get('/api/{{RESOURCE_NAME_LOWER}}?_count=5');

    // Should return 200 or 404 (if no data), but not 500
    expect([200, 404].includes(response.status())).toBeTruthy();

    if (response.status() === 200) {
      const bundle = await response.json();
      expect(bundle.resourceType).toBe('Bundle');
      expect(bundle.type).toBe('searchset');
      expect(bundle.total).toBeGreaterThanOrEqual(0);
      expect(Array.isArray(bundle.entry)).toBeTruthy();
    }
  });

  test('{{RESOURCE_NAME}} search endpoint works', async ({ request }) => {
    const response = await request.get('/api/{{RESOURCE_NAME_LOWER}}/search?_count=1');

    expect([200, 404].includes(response.status())).toBeTruthy();

    if (response.status() === 200) {
      const bundle = await response.json();
      expect(bundle.resourceType).toBe('Bundle');
      expect(bundle.meta).toBeDefined();
      expect(bundle.meta.tag).toBeDefined();
      expect(bundle.meta.tag[0].code).toBe('advanced-search');
    }
  });

{{/EACH_RESOURCE}}

  test('FHIR capability statement can be retrieved through proxy', async ({ request }) => {
    const response = await request.get('/api/fhir/metadata');

    // Should successfully proxy to the FHIR server
    expect([200, 404, 503].includes(response.status())).toBeTruthy();

    if (response.status() === 200) {
      const capability = await response.json();
      expect(capability.resourceType).toBe('CapabilityStatement');
      expect(capability.fhirVersion).toBeDefined();
    }
  });

  test('invalid resource type returns appropriate error', async ({ request }) => {
    const response = await request.get('/api/invalidresource');
    expect(response.status()).toBe(404);
  });

  test('readiness check passes', async ({ request }) => {
    const response = await request.get('/ready');

    // Should be either ready (200) or temporarily unavailable (503)
    expect([200, 503].includes(response.status())).toBeTruthy();

    const readiness = await response.json();
    expect(readiness.timestamp).toBeDefined();
    expect(typeof readiness.ready).toBe('boolean');
    expect(readiness.checks).toBeDefined();
    expect(readiness.checks.fhir).toBeDefined();
    expect(readiness.checks.memory).toBeDefined();
  });

  test('liveness check always passes', async ({ request }) => {
    const response = await request.get('/live');
    expect(response.status()).toBe(200);

    const liveness = await response.json();
    expect(liveness.status).toBe('alive');
    expect(liveness.timestamp).toBeDefined();
    expect(typeof liveness.uptime).toBe('number');
  });

  test('metrics endpoint provides application metrics', async ({ request }) => {
    const response = await request.get('/metrics');
    expect(response.status()).toBe(200);

    const metrics = await response.json();
    expect(metrics.application).toBe('{{APP_NAME}}');
    expect(metrics.process).toBeDefined();
    expect(metrics.memory).toBeDefined();
    expect(metrics.cpu).toBeDefined();
    expect(typeof metrics.process.uptime).toBe('number');
  });

  test('CORS headers are properly set', async ({ request }) => {
    const response = await request.get('/health', {
      headers: {
        'Origin': 'http://localhost:3000'
      }
    });

    expect(response.status()).toBe(200);

    // Check CORS headers
    const headers = response.headers();
    expect(headers['access-control-allow-origin']).toBeDefined();
  });

  test('API returns proper FHIR content-type headers', async ({ request }) => {
    const response = await request.get('/api/fhir');
    expect(response.status()).toBe(200);

    const contentType = response.headers()['content-type'];
    expect(contentType).toContain('application/json');
  });

  test('error responses include proper FHIR OperationOutcome structure', async ({ request }) => {
    // Try to access a specific resource that likely doesn't exist
    const response = await request.get('/api/patient/nonexistent-id-12345');

    if (response.status() >= 400) {
      const error = await response.json();

      // Should be a valid FHIR OperationOutcome
      expect(error.resourceType).toBe('OperationOutcome');
      expect(Array.isArray(error.issue)).toBeTruthy();
      expect(error.issue.length).toBeGreaterThan(0);
      expect(error.issue[0].severity).toBeDefined();
      expect(error.issue[0].code).toBeDefined();
    }
  });
});

test.describe('{{APP_NAME}} - Integration Tests', () => {
  test('can create and retrieve a Patient resource', async ({ request }) => {
    // Skip if this is a read-only FHIR server
    const testPatient = {
      resourceType: 'Patient',
      name: [{
        family: 'TestPatient',
        given: ['PlaywrightTest']
      }],
      identifier: [{
        system: 'http://fhiriq.com/test',
        value: `test-${Date.now()}`
      }]
    };

    // Try to create a patient
    const createResponse = await request.post('/api/patient', {
      data: testPatient
    });

    if (createResponse.status() === 201) {
      const createdPatient = await createResponse.json();
      expect(createdPatient.resourceType).toBe('Patient');
      expect(createdPatient.id).toBeDefined();

      // Try to retrieve the created patient
      const readResponse = await request.get(`/api/patient/${createdPatient.id}`);
      expect(readResponse.status()).toBe(200);

      const retrievedPatient = await readResponse.json();
      expect(retrievedPatient.id).toBe(createdPatient.id);
      expect(retrievedPatient.name[0].family).toBe('TestPatient');

      // Clean up - try to delete the test patient
      await request.delete(`/api/patient/${createdPatient.id}`);
    } else {
      // If creation failed, log the response for debugging
      console.log('Patient creation failed (may be read-only server):', createResponse.status());

      // Test should not fail for read-only servers
      expect([403, 405, 501].includes(createResponse.status())).toBeTruthy();
    }
  });

{{#IF_RESOURCE:Observation}}
  test('can search for Observations with parameters', async ({ request }) => {
    const response = await request.get('/api/observation?code=vital-signs&_count=10');

    expect([200, 404].includes(response.status())).toBeTruthy();

    if (response.status() === 200) {
      const bundle = await response.json();
      expect(bundle.resourceType).toBe('Bundle');
      expect(bundle.type).toBe('searchset');

      // Check that returned entries are Observation resources
      if (bundle.entry && bundle.entry.length > 0) {
        bundle.entry.forEach(entry => {
          expect(entry.resource.resourceType).toBe('Observation');
        });
      }
    }
  });
{{/IF_RESOURCE:Observation}}

{{#IF_RESOURCE:Patient}}
  test('patient search returns proper Bundle structure', async ({ request }) => {
    const response = await request.get('/api/patient?_count=5&_sort=-_lastUpdated');

    expect([200, 404].includes(response.status())).toBeTruthy();

    if (response.status() === 200) {
      const bundle = await response.json();
      expect(bundle.resourceType).toBe('Bundle');
      expect(bundle.type).toBe('searchset');
      expect(typeof bundle.total).toBe('number');

      // Verify FHIR IQ Builder meta tag
      expect(bundle.meta).toBeDefined();
      expect(bundle.meta.tag).toBeDefined();
      expect(bundle.meta.tag[0].system).toBe('http://fhiriq.com/tags');
      expect(bundle.meta.tag[0].code).toBe('generated-api');
    }
  });
{{/IF_RESOURCE:Patient}}

  test('server handles malformed FHIR requests gracefully', async ({ request }) => {
    const response = await request.post('/api/patient', {
      data: {
        resourceType: 'InvalidResource',
        invalidField: 'test'
      }
    });

    // Should return a proper error response
    expect(response.status()).toBeGreaterThanOrEqual(400);

    const error = await response.json();
    expect(error.resourceType).toBe('OperationOutcome');
    expect(error.issue).toBeDefined();
  });

  test('FHIR validation endpoint works if supported', async ({ request }) => {
    const testResource = {
      resourceType: 'Patient',
      name: [{
        family: 'ValidationTest'
      }]
    };

    const response = await request.post('/api/fhir/Patient/$validate', {
      data: testResource
    });

    // Validation might not be supported by all FHIR servers
    if (response.status() === 200) {
      const result = await response.json();
      expect(result.resourceType).toBe('OperationOutcome');
    } else {
      // If not supported, should return 404 or 501
      expect([404, 501, 405].includes(response.status())).toBeTruthy();
    }
  });
});

test.describe('{{APP_NAME}} - Performance Tests', () => {
  test('health check responds quickly', async ({ request }) => {
    const startTime = Date.now();
    const response = await request.get('/health');
    const responseTime = Date.now() - startTime;

    expect(response.status()).toBe(200);
    expect(responseTime).toBeLessThan(5000); // Should respond within 5 seconds
  });

  test('FHIR API responses include timing information', async ({ request }) => {
    const response = await request.get('/api/fhir');
    expect(response.status()).toBe(200);

    // Check response headers for timing information
    const headers = response.headers();
    expect(headers['x-response-time'] || headers['server-timing']).toBeDefined();
  });

  test('large search results are properly paginated', async ({ request }) => {
    const response = await request.get('/api/patient?_count=1000');

    if (response.status() === 200) {
      const bundle = await response.json();

      // Most FHIR servers will limit results regardless of _count parameter
      expect(bundle.entry ? bundle.entry.length : 0).toBeLessThanOrEqual(100);

      // Should include pagination links if there are more results
      if (bundle.total > (bundle.entry ? bundle.entry.length : 0)) {
        expect(bundle.link).toBeDefined();
        expect(bundle.link.some(link => link.relation === 'next')).toBeTruthy();
      }
    }
  });
});

test.describe('{{APP_NAME}} - Error Handling', () => {
  test('handles network errors to FHIR server gracefully', async ({ request }) => {
    // Test with an invalid FHIR server URL by making a request
    // that should fail if the FHIR server is unreachable

    const response = await request.get('/health');

    if (response.status() === 503) {
      // Service unavailable due to FHIR server issues
      const health = await response.json();
      expect(health.status).toBe('degraded');
      expect(health.fhir.status).toBe('disconnected');
      expect(health.fhir.error).toBeDefined();
    } else {
      // FHIR server is available
      expect(response.status()).toBe(200);
    }
  });

  test('returns proper error format for invalid JSON', async ({ request }) => {
    const response = await request.post('/api/patient', {
      data: 'invalid json string',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(response.status()).toBeGreaterThanOrEqual(400);

    const error = await response.json();
    expect(error.error).toBeDefined();
    expect(error.timestamp).toBeDefined();
  });

  test('handles rate limiting appropriately', async ({ request }) => {
    // Make multiple rapid requests to test rate limiting
    const promises = Array.from({ length: 10 }, () =>
      request.get('/api/fhir')
    );

    const responses = await Promise.all(promises);

    // All should succeed or some should be rate limited
    responses.forEach(response => {
      expect([200, 429, 503].includes(response.status())).toBeTruthy();
    });
  });
});

test.describe('{{APP_NAME}} - Security Tests', () => {
  test('does not expose sensitive information in errors', async ({ request }) => {
    const response = await request.get('/api/nonexistent-endpoint');
    expect(response.status()).toBe(404);

    const error = await response.json();

    // Should not expose internal paths, stack traces, or environment variables
    const errorString = JSON.stringify(error).toLowerCase();
    expect(errorString).not.toContain('password');
    expect(errorString).not.toContain('secret');
    expect(errorString).not.toContain('token');
    expect(errorString).not.toContain('/app/');
    expect(errorString).not.toContain('c:\\');
  });

  test('sets appropriate security headers', async ({ request }) => {
    const response = await request.get('/health');
    const headers = response.headers();

    // Check for basic security headers
    expect(headers['x-content-type-options']).toBe('nosniff');
    expect(headers['x-frame-options']).toBeDefined();
    expect(headers['x-xss-protection']).toBeDefined();
  });

  test('validates content-type for POST requests', async ({ request }) => {
    const response = await request.post('/api/patient', {
      data: 'test data',
      headers: {
        'Content-Type': 'text/plain'
      }
    });

    // Should reject non-FHIR content types
    expect([400, 415].includes(response.status())).toBeTruthy();
  });
});