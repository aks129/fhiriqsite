import { promises as fs } from 'fs';
import path from 'path';
import { logger } from '../utils/logger.js';

export interface TemplateContext {
  capabilityStatementUrl: string;
  stack: string;
  resources: string[];
  appName?: string;
  description?: string;
  features?: string[];
  serverUrl: string;
  supportedResources: string[];
  interactions: Record<string, string[]>;
  searchParameters: Record<string, string[]>;
}

export class TemplateService {
  private templatesDir: string;

  constructor() {
    this.templatesDir = path.join(process.cwd(), '..', 'templates');
  }

  /**
   * Generates a complete application from templates
   */
  async generateApplication(outputDir: string, context: TemplateContext): Promise<void> {
    const templateDir = path.join(this.templatesDir, context.stack);

    try {
      // Ensure template directory exists
      await fs.access(templateDir);
    } catch {
      throw new Error(`Template not found for stack: ${context.stack}`);
    }

    logger.info('Generating application from template', {
      stack: context.stack,
      outputDir,
      resources: context.resources
    });

    // Copy template structure
    await this.copyTemplateStructure(templateDir, outputDir);

    // Process template files with context
    await this.processTemplateFiles(outputDir, context);

    // Generate resource-specific components
    await this.generateResourceComponents(outputDir, context);

    logger.info('Application generation completed', { outputDir });
  }

  private async copyTemplateStructure(templateDir: string, outputDir: string): Promise<void> {
    const entries = await fs.readdir(templateDir, { withFileTypes: true });

    for (const entry of entries) {
      const srcPath = path.join(templateDir, entry.name);
      const destPath = path.join(outputDir, entry.name);

      if (entry.isDirectory()) {
        await fs.mkdir(destPath, { recursive: true });
        await this.copyTemplateStructure(srcPath, destPath);
      } else {
        await fs.copyFile(srcPath, destPath);
      }
    }
  }

  private async processTemplateFiles(outputDir: string, context: TemplateContext): Promise<void> {
    const templateFiles = await this.findTemplateFiles(outputDir);

    for (const filePath of templateFiles) {
      await this.processTemplateFile(filePath, context);
    }
  }

  private async findTemplateFiles(dir: string): Promise<string[]> {
    const files: string[] = [];
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        const subFiles = await this.findTemplateFiles(fullPath);
        files.push(...subFiles);
      } else if (this.isTemplateFile(entry.name)) {
        files.push(fullPath);
      }
    }

    return files;
  }

  private isTemplateFile(filename: string): boolean {
    const templateExtensions = ['.template', '.mustache', '.hbs'];
    return templateExtensions.some(ext => filename.includes(ext)) ||
           filename.includes('.template.') ||
           filename.endsWith('.js') ||
           filename.endsWith('.ts') ||
           filename.endsWith('.jsx') ||
           filename.endsWith('.tsx') ||
           filename.endsWith('.json') ||
           filename.endsWith('.md');
  }

  private async processTemplateFile(filePath: string, context: TemplateContext): Promise<void> {
    try {
      let content = await fs.readFile(filePath, 'utf-8');

      // Replace template variables
      content = this.replaceTemplateVariables(content, context);

      // Remove .template extension if present
      const outputPath = filePath.replace(/\.template(\.[^.]+)?$/, '$1');

      await fs.writeFile(outputPath, content);

      // Remove original template file if it had .template extension
      if (filePath !== outputPath) {
        await fs.unlink(filePath);
      }

    } catch (error) {
      logger.error('Failed to process template file', { filePath, error: error.message });
      throw error;
    }
  }

  private replaceTemplateVariables(content: string, context: TemplateContext): string {
    // Basic template variable replacement
    const variables = {
      '{{APP_NAME}}': context.appName || 'FHIR Application',
      '{{APP_DESCRIPTION}}': context.description || 'A FHIR application generated by FHIR IQ Builder',
      '{{FHIR_SERVER_URL}}': context.serverUrl,
      '{{CAPABILITY_STATEMENT_URL}}': context.capabilityStatementUrl,
      '{{FHIR_RESOURCES}}': JSON.stringify(context.resources, null, 2),
      '{{SUPPORTED_RESOURCES}}': JSON.stringify(context.supportedResources, null, 2),
      '{{SEARCH_PARAMETERS}}': JSON.stringify(context.searchParameters, null, 2),
      '{{INTERACTIONS}}': JSON.stringify(context.interactions, null, 2),
      '{{FEATURES}}': JSON.stringify(context.features || [], null, 2),
      '{{GENERATED_AT}}': new Date().toISOString(),
      '{{GENERATOR}}': 'FHIR IQ Builder v1.0'
    };

    let processedContent = content;

    for (const [placeholder, value] of Object.entries(variables)) {
      processedContent = processedContent.replace(new RegExp(placeholder, 'g'), value);
    }

    // Process resource-specific placeholders
    processedContent = this.processResourcePlaceholders(processedContent, context);

    return processedContent;
  }

  private processResourcePlaceholders(content: string, context: TemplateContext): string {
    let processedContent = content;

    // Replace {{#EACH_RESOURCE}} blocks
    const resourceBlockRegex = /{{#EACH_RESOURCE}}([\s\S]*?){{\/EACH_RESOURCE}}/g;
    processedContent = processedContent.replace(resourceBlockRegex, (match, block) => {
      return context.resources.map(resource => {
        return block
          .replace(/{{RESOURCE_NAME}}/g, resource)
          .replace(/{{RESOURCE_NAME_LOWER}}/g, resource.toLowerCase())
          .replace(/{{RESOURCE_NAME_CAMEL}}/g, this.toCamelCase(resource))
          .replace(/{{RESOURCE_NAME_PASCAL}}/g, this.toPascalCase(resource));
      }).join('\n');
    });

    // Replace {{#IF_RESOURCE:ResourceName}} blocks
    const ifResourceRegex = /{{#IF_RESOURCE:(\w+)}}([\s\S]*?){{\/IF_RESOURCE:\1}}/g;
    processedContent = processedContent.replace(ifResourceRegex, (match, resourceName, block) => {
      return context.resources.includes(resourceName) ? block : '';
    });

    return processedContent;
  }

  private async generateResourceComponents(outputDir: string, context: TemplateContext): Promise<void> {
    // Generate individual resource components based on the selected resources
    for (const resource of context.resources) {
      await this.generateResourceComponent(outputDir, resource, context);
    }
  }

  private async generateResourceComponent(
    outputDir: string,
    resource: string,
    context: TemplateContext
  ): Promise<void> {
    const componentDir = path.join(outputDir, 'src', 'components');
    await fs.mkdir(componentDir, { recursive: true });

    const componentTemplate = this.getResourceComponentTemplate(resource, context);
    const componentPath = path.join(componentDir, `${resource}Component.jsx`);

    await fs.writeFile(componentPath, componentTemplate);

    logger.debug('Generated resource component', { resource, componentPath });
  }

  private getResourceComponentTemplate(resource: string, context: TemplateContext): string {
    const resourceLower = resource.toLowerCase();
    const resourceCamel = this.toCamelCase(resource);

    return `import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardContent } from '../ui/Card';
import { Button } from '../ui/Button';
import { Badge } from '../ui/Badge';
import { fhirClient } from '../services/fhirClient';

const ${resource}Component = () => {
  const [${resourceCamel}s, set${resource}s] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch${resource}s();
  }, []);

  const fetch${resource}s = async () => {
    try {
      setLoading(true);
      const response = await fhirClient.search({
        resourceType: '${resource}',
        searchParams: {
          _count: 10,
          _sort: '-_lastUpdated'
        }
      });

      set${resource}s(response.entry || []);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch ${resourceLower}s:', err);
      setError('Failed to load ${resourceLower}s. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const refresh = () => {
    fetch${resource}s();
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
            <span className="ml-2">Loading ${resourceLower}s...</span>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="text-center">
            <p className="text-red-600 mb-4">{error}</p>
            <Button onClick={refresh} variant="outline">
              Try Again
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <h3 className="text-lg font-semibold">${resource}s</h3>
        <div className="flex items-center space-x-2">
          <Badge variant="secondary">{${resourceCamel}s.length} items</Badge>
          <Button onClick={refresh} variant="outline" size="sm">
            Refresh
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {${resourceCamel}s.length === 0 ? (
          <p className="text-gray-500 text-center py-4">No ${resourceLower}s found.</p>
        ) : (
          <div className="space-y-4">
            {${resourceCamel}s.map((entry, index) => {
              const ${resourceCamel} = entry.resource;
              return (
                <div
                  key={${resourceCamel}.id || index}
                  className="border rounded-lg p-4 hover:bg-gray-50"
                >
                  <div className="flex items-start justify-between">
                    <div>
                      <h4 className="font-medium">
                        ${resource} ID: {${resourceCamel}.id}
                      </h4>
                      <p className="text-sm text-gray-600 mt-1">
                        Last Updated: {new Date(${resourceCamel}.meta?.lastUpdated).toLocaleDateString()}
                      </p>
                    </div>
                    <Badge variant="outline">
                      {${resourceCamel}.resourceType}
                    </Badge>
                  </div>

                  <div className="mt-3">
                    <details>
                      <summary className="cursor-pointer text-sm text-blue-600 hover:text-blue-800">
                        View Details
                      </summary>
                      <pre className="mt-2 p-3 bg-gray-100 rounded text-xs overflow-auto">
                        {JSON.stringify(${resourceCamel}, null, 2)}
                      </pre>
                    </details>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default ${resource}Component;`;
  }

  private toCamelCase(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1);
  }

  private toPascalCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}